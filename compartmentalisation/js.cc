// Copyright Microsoft and CHERIoT Contributors.
// SPDX-License-Identifier: MIT

#define MALLOC_QUOTA 32000
#include "secret.h"
#include <cheriot-atomic.hh>
#include <compartment.h>
#include <debug.hh>
#include <errno.h>
#include <interrupt.h>
#include <platform-gpio.hh>
#include <riscvreg.h>
#include <thread.h>
#include <tick_macros.h>
#include <type_traits>
#include <vector>

/// Expose debugging features unconditionally for this compartment.
using Debug = ConditionalDebug<true, "JavaScript compartment">;
using CHERI::Capability;

/// Thread entry point.
void __cheri_compartment(ENTRY_COMPARTMENT)
run_tick()
{
	while (true)
	{
		Timeout t{MS_TO_TICKS(500)};
		thread_sleep(&t, ThreadSleepNoEarlyWake);
		int ret = tick();
		if (ret == -ECOMPARTMENTFAIL)
		{
			Debug::log("JavaScript compartment crashed during tick");
		}
	}
}

/// Thread entry point.
void __cheri_compartment(ENTRY_COMPARTMENT)
run()
{
#if DEVICE_EXISTS(gpio_led0)
	// The Arty A7 GPIOs require explicitly enabling before they work.
	MMIO_CAPABILITY(GPIO, gpio_led0)->enable_all();
#endif

	// Set the secret value on startup.
	set_secret();
	Debug::log("Starting...");

	auto uart = MMIO_CAPABILITY(Uart, uart);

	ssize_t character = 0;

	// Get a capability to the UART.
	auto uart_blocking_read = [&]() {
		character++;
		return uart->blocking_read();
	};

	// Helper that reads a character and errors if it isn't the expected
	// one.
#define SKIP(byte)                                                             \
	{                                                                          \
		char c = uart_blocking_read();                                         \
		if (c != byte)                                                         \
		{                                                                      \
			Debug::log(                                                        \
			  "Read '{}', expected '{}' (character {})", c, byte, character);  \
			break;                                                             \
		}                                                                      \
	}

	// Helper that reads from the UART until a specific character is seen
	auto skipUntil = [&](char byte) {
		while (uart_blocking_read() != byte) {}
	};

	// Helper that converts a hex character to an integer.  Returns 0 on
	// invalid values.
	auto hexByteToNumber = [](char c) {
		switch (c)
		{
			case '0' ... '9':
				return c - '0';
			case 'a' ... 'f':
				return c - 'a' + 10;
			case 'A' ... 'F':
				return c - 'A' + 10;
		}
		return 0;
	};

	auto isHexDigit = [](char c) {
		switch (c)
		{
			default:
				return false;
			case '0' ... '9':
			case 'a' ... 'f':
			case 'A' ... 'F':
				return true;
		}
	};

	while (true)
	{
		// Create a vector to hold the bytecode.
#if 0
		std::vector<uint8_t> bytecode;
		Debug::log("Allocating memory for bytecode");
		bytecode.reserve(2048);
		Debug::log("Allocated memory for bytecode ({} bytes}",
		           bytecode.capacity());
#endif
		std::vector<uint8_t> bytecode;
		bytecode.reserve(1024);

		// Read values in the form generated by microvium's hex output: a
		// series of hex bytes in braces.
		bool readCompleteScript = false;
		Debug::log("Ready to load new JavaScript");
		skipUntil('{');
		CHERI::with_interrupts_disabled([&]() {
			while (true)
			{
				char buffer[5];
				buffer[0] = uart->blocking_read();
				buffer[1] = uart->blocking_read();
				buffer[2] = uart->blocking_read();
				buffer[3] = uart->blocking_read();
				buffer[4] = uart->blocking_read();
				if ((buffer[0] == '0') && (buffer[1] == 'x') &&
				    isHexDigit(buffer[2]) && isHexDigit(buffer[3]))
				{
					uint8_t byte = hexByteToNumber(buffer[2]) << 4;
					byte += hexByteToNumber(buffer[3]);
					bytecode.push_back(byte);
					if (__builtin_expect(buffer[4] == ',', true))
					{
						continue;
					}
					if (__builtin_expect(buffer[4] == '}', false))
					{
						readCompleteScript = true;
						Debug::log("Read entire message, {} bytes",
						           bytecode.size());
						break;
					}
				}
				Debug::log("Unexpected values for byte {}: {}{}{}{}{}",
				           bytecode.size(),
				           buffer[0],
				           buffer[1],
				           buffer[2],
				           buffer[3],
				           buffer[4]);
				Debug::log(
				  "Stopping JavaScript to prevent interference with loading.");
				kill();
				break;
			}
		});

		if (!readCompleteScript)
		{
			Debug::log("Error reading script");
			continue;
		}

		Debug::log("Read {} bytes of bytecode", bytecode.size());

		// Stop the JavaScript compartment
		kill();
		if (load_javascript(bytecode.data(), bytecode.size()) != 0)
		{
			Debug::log("JavaScript compartment returned error");
		}
	}
}
